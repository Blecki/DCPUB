#include lem.dc
#include console.dc
#include vec.dc
#include itoa.dc
#include keyboard.dc
#include memory.dc

local i;
local error_string = 0;
static outer_memory = __endofprogram;			//Reserve half of available memory as the heap. This means a larger
initialize_memory_page(outer_memory, 0x8000);	//program makes for a smaller stack.
static lem_display;
lem_display = detect_lem();						

local lem_vram = allocate_memory(LEM_VRAM_SIZE, outer_memory); //Allocate vram.
if (lem_vram == 0)
{
	error_string = "Err alloc vram";
	goto error_exit;
}	

initialize_lem(lem_display, lem_vram);			
static console[sizeof(console)];				//Allocate static space for the console
console_make(console, lem_vram);				//Create the console
static keyboard;
keyboard = find_keyboard();

constant world_width = 64;
constant world_height = 64;

struct tile
{
	type;
}

console_stringout(console, "Alloc world...");
local world = allocate_memory(sizeof(tile) * world_width * world_height, outer_memory);
console_stringout(console, "Done!");

function get_tile(x, y, world):tile
{
	return world + (sizeof(tile) * ((y * world_width) + x));
}

struct actor
{
	character;
	x;
	y;
	next_actor;
}

static first_free_actor:actor;
first_free_actor = allocate_memory(sizeof(actor) * 32, outer_memory);
if (first_free_actor == 0)
{
	error_string = "memalloc err: actors";
	goto error_exit;
}

i = 0;
while (i < 32)
{
	(first_free_actor + (i * sizeof(actor))):actor.next_actor = first_free_actor + ((i + 1) * sizeof(actor));
	i += 1;
}

function allocate_actor()
{
	if (first_free_actor == 0) return 0;
	local result = first_free_actor;
	first_free_actor = first_free_actor.next_actor;
	return result;
}

function free_actor(actor:actor)
{
	actor.next_actor = first_free_actor;
	first_free_actor = actor;
}

local player:actor = allocate_actor();
player.character = '@';
player.x = 16;
player.y = 16;
player.next_actor = 0;

//Initialize world
//Todo: Document pointer / array behavior of DCPUC
i = 0;
while (i < (world_width * world_height))
{

	(world + (sizeof(tile) * i)):tile.type = '#';
	i += 1;
}


//Draw the board to vram, with x,y at the top,left.
function draw_board(vram, world, x, y)
{
	local _x = 0;
	local _y = 0;

	while (_x < console_width)
	{
		_y = 0;
		while (_y < console_height)
		{
			local tx = _x + x;
			local ty = _y + y;
			if ((tx < world_width) & (ty < world_height))
			{
				local tile:tile = get_tile(tx, ty, world);
				vram[(_y * console_width) + _x] = 0xF000 | tile.type;
			}
			_y += 1;
		}
		_x += 1;
	}
}

draw_board(lem_vram, world, 0, 0);
//draw actors
local current_actor:actor = player;
while (current_actor != 0)
{
	local tx = current_actor.x - 0;
	local ty = current_actor.y - 0;
	if ((tx < console_width) & (ty < console_height))
	{
		lem_vram[(ty * console_width) + tx] = 0xF000 | current_actor.character;
	}
	current_actor = current_actor.next_actor;
}

:error_exit;
initialize_lem(lem_display, __endofprogram);
console_make(console, __endofprogram);
if (error_string != 0)
{
	console_stringout(console, error_string);
}
else
{
	console_stringout(console, "No error.");
}
